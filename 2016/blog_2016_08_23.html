<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<link rel="Shortcut Icon" href="https://avatars2.githubusercontent.com/u/6932025?v=3&s=460" type="image/ico">
<title>vue.js路由(一)</title>
<style type="text/css">
    #content{margin:0 auto 50px; width: 66%;}
    #disqus_thread{margin:0 auto; width: 66%;}
	.ds-powered-by,.navbar ,.ds-sync{display: none;}
</style>
<xmp theme="united" style="display:none;">
##vue.js路由

一、基本用法

步骤：

a、创建组件

b、路由器需要一个根组件

c、创建一个路由器实例

d、定义路由规则

e、启动应用

```
html

<div id="app">
    <p>
        <a v-link="{path:'/foo'}">foo页面</a>
        <a v-link="{path:'/bar'}">bar页面</a>
        <a v-link="{path:'/header'}">header页面</a>
        <a v-link="{path:'/footer'}">footer页面</a>
    </p>
    <!-- 组件渲染的地方   路由外链 -->
    <router-view></router-view>
</div>

js

1、创建组件

var Foo=Vue.extend({
    template:"<p>这是foo页面</p>"
})
var Bar=Vue.extend({
    template:"<p>这是bar页面</p>"
})
var Header=Vue.extend({
    template:"<p>这是header页面</p>"
})
var Footer=Vue.extend({
    template:"<p>这是footer页面</p>"
})

2、路由器需要一个根组件

var App=Vue.extend({})

3、创建一个路由器实例
var router=new VueRouter()

4、定义路由规则,每条路由规则应该映射到一个组件。这里的“组件”可以是一个使用 Vue.extend
router.map({
    '/foo':{
        component:Foo
    },
    '/bar':{
        component:Bar
    },
    '/header':{
        component:Header
    },
    '/footer':{
        component:Footer
    }

})

5、启动应用。路由器会创建一个根实例(App)，并且挂载到选择符 #app 匹配的元素上。
router.start(App,"#app")
```
二、嵌套路由

```
html
<div id="app">
    <p>
      <a v-link="{path:'/foo'}">go to /foo</a>
      <a v-link="{path:'/foo/bar'}">go to /foo/bar</a>
      <a v-link="{path:'/foo/baz'}">go to /foo/baz</a>
    </p>
    <router-view></router-view>
  </div>

js
  //创建组件
    var Foo=Vue.extend({
      template:
        '<div class="foo">'+
          '<h1>this is foo!</h1>'+
          '<router-view></router-view>'+
          '</div>'
    })
    var Bar=Vue.extend({
      template:'<p>this is bar</p>'
    })
    var Baz=Vue.extend({
      template:'<p>this is baz</p>'
    })
  //路由器需要一个根组件
    var App=Vue.extend({})

  //路由器需要一个实例
    var router=new VueRouter()

  //路由规则
    router.map({
      "/foo":{
        component:Foo,
        subRoutes:{   //组件在第二个路由里渲染
          '/':{
            component:{
              template:'<p>this is default message show</p>'
            }
          },
          "/bar":{
            component:Bar
          },
          "/baz":{
            component:Baz
          }
        }
      }
      
    })      
  //启动应用
    router.start(App,"#app")
```
三、路由规则(对象)和路由匹配

(一、)路由规则(对象)

1、路由对象暴露的属性

a、$route.path

等于当前路由对象的路径，被解析为绝对路径，如:"/foo/bar"

b、$route.name

当前路由的名字

c、$route.route

路由规则所属的路由器

d、$route.matched

数组,当前匹配的路径中所包含的所有对应的配置参数

e、$route.query

对象，路由中查询参数的键值对，如:/foo?user=1 

f、$route.params

对象,路由中动态片段和全匹配片段的键值对

2、在模板中使用$route

```
<div>
  <p>当前路径:{{$route.path}}</p>
  <p>当前路径的参数:{{$route.params | json}}</p>
</div>

```

(二、)路由匹配

1、动态片段

动态片段使用以冒号开头的路径片段定义，例如 user/:username 中，:username 就是动态片段。

一条路径中可以包含多个动态片段，每个片段都会被解析成 $route.params 的一个键值对。

```
router.map({
  '/user/:username': {
    component: {
      template: '<p>用户名是{{$route.params.username}}</p>'
    }
  }
})

/user/:username/post/:post_id(模式)    /user/evan/post/123 (匹配的路径)   { username: 'evan', post_id: 123 }($route.params)
```
2、全匹配片段

动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版。例如 /foo/*bar 会匹配任何以 /foo/ 开头的路径。

```
/user/*foo/bar(模式)  /user/a/b/bar(匹配的路径) {foo:'a/b'}($route.params) 
```

四、具名路径(有具体的名字)

在有些情况下，给一条路径加上一个名字能够让我们更方便地进行路径的跳转。

```
html

<div id="app">
    <p>
      <a v-link="{name:'user' , params:{ userId: 123 }}">go to /foo</a>
    </p>
    <router-view></router-view>
  </div>

  js

  var User=Vue.extend({
      template:'<p>this is foo</p>'
    })

    var App=Vue.extend({})

    var router=new VueRouter()

    router.map({
      '/user/:userId':{
        name:'user',
        component:User
      }
    })

    router.start(App,"#app")
```

五、router-view

<router-view></router-view>

用于渲染匹配的组件

六、v-link

是一个让用户在vue-router不同路径间跳转的一个指令。

1、三种书写方式

```
<!-- 字面量路径 -->

<a link="'home'"></a>

<!-- 效果同上 -->

<a link="path:'/home' "></a>

<!-- 具名路径 -->

<a link="{name:'user' , params:{userId:123} }"></a>
```
2、replace

一个带有 replace: true 的链接被点击时将会触发 router.replace() 而不是 router.go()。由此产生的跳转不会留下历史记录：

` <a v-link="{ path: '/abc', replace: true }"></a> `

3、append

带有 append: true 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 /a 跳转到相对路径 b 时，如果没有 append: true 我们会跳转到 /b，但有 append: true 则会跳转到 /a/b。

` <a v-link="{ path: 'relative/path', append: true }"></a> `


七、动态组件载入(异步)


动态组件载入不再是之前所述的直接引用一个组件，而是需要通过定义一个函数返回一个组件；

```
  router.map({
    '/async':{
        component:function(resolve){
          resolve(MyComponent)
        }
    }
  })
```

手动引入组件并不理想，有幸 Webpack 和 Browserify 都提供了简单的解决方案。

**Webpack**

可以使用AMD风格的require来对代码标识代码分割点：

```
require(['./MyComponent.vue'],function(MyComponent){
  
})

和路由配合使用，如下：

router.map({
  './async':{
      component:function(resolve){
        require(['./MyComponent.vue'],resolve)
      }
  }
})

现在只要async需要被渲染时，MyComponent.vue组件会自动加载它的依赖组件，并且异步加载进来；
```
























</xmp>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//httpsfedlovergithubio.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script src="https://fedlover.github.io/js/strapdown.js"></script>
</html>

	