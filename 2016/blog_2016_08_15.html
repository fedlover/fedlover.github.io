<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<link rel="Shortcut Icon" href="https://avatars2.githubusercontent.com/u/6932025?v=3&s=460" type="image/ico">
<title>vue.js(三)</title>
<style type="text/css">
    #content{margin:0 auto 50px; width: 66%;}
    #disqus_thread{margin:0 auto; width: 66%;}
	.ds-powered-by,.navbar ,.ds-sync{display: none;}
</style>
<xmp theme="united" style="display:none;">

##vue.js(三)

####十、组件

一、含义:是vue.js最强大的功能之一，扩展HTML元素，封装可重用的代码。

二、使用组件

1、全局注册(步骤)

a、先通过Vue.extend()创建组件构造器；

b、通过使用Vue.component()注册，来把构造器用作组件；

c、组件注册后，便可以在父实例模块中通过自定义元素使用(创建根实例)；

```
html

<div id="app">
  <my-component></my-component>
</div>

js

//先创建组件构造器

var MyComponent=Vue.extend({
  template:'<ul><li><h5>11111</h5></li><li><h5>22222</h5></li><li><h5>33333</h5></li><li><h5>44444</h5></li><li><h5>55555</h5></li></ul>'
})

//注册(把构造器用作组件)(用组件的模块Mycomponent替换了自定义元素my-conpoment)
Vue.component('my-conpoment',Mycomponent)

//创建根实例

var vm=new Vue({
  el:"#app"
})
```
2、局部注册(components)

不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 components 注册：

```
html:
<div id="app">
  <parent></parent>
</div>

js:

//创建子组件构造器
var Child=Vue.extend({
  template:"<div>child</div>"
})
//创建父组件构造器，并把子组件放到父模块中
var Parent=Vue.extend({
  template:"<div><h4>父组件：<child></child></h4></div>",
  注册子组件：
  components:{
    "child":Child
  }

})
//创建根实例

var vm=new Vue({
  el:"#app",
  注册父组件
  components:{
    "parent":Parent
  }
})

```
3、注册语法糖(不需要创建组件构造器)：

为了让事件更简单，可以直接传入选项对象而不是构造器给 Vue.component() 和 component 选项。Vue.js 在背后自动调用 Vue.extend()：

```
全局：
Vue.component("my-component",{
  template:'<ul><li><h5>11111</h5></li><li><h5>22222</h5></li><li><h5>33333</h5></li><li><h5>44444</h5></li><li><h5>55555</h5></li></ul>'
})

局部：

var Parent=Vue.extend({
  template:"<div>parent: <child></child></div>",
  components:{
    "child":{
        template:'<div>child</div>'
    }
  }
})
var vm=new Vue({
  el:"#app",
  components:{
    "parent":Parent
  }
})

```
4、组件选项问题
在vue.js构造器(Vue.extend)中data和el必须作为一个函数使用。

`var MyComponent = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
`
三、Props

1、使用props传递数据

不能在子组件的模板内直接使用父组件的数据，要通过Props把数据传给子组件。

```
html
<div id="app">
  <child msg="hello"></child>
</div>

js
var Child=Vue.component("child",{
显式地用 props 选项 声明 props：
  props:['msg'],
  template:'<span>{{msg}}</span>'-->通过props拿到父元素的数据“hello”
})
var vm=new Vue({
  el:"#app"
})
```
**2、动态props**

用v-bind绑定动态的props到父组件的数据。每当父组件数据变化时，子组件也会相应的改变。

```
html

<div id="app">
  <input v-model="parentMsg">
  <br>
  <child v-bind:message="parentMsg"></child>
</div>

js

var Child=Vue.component("child",{
  props:['message'],
  template:'<div><span>{{message}}</span></div>'
})
var vm=new Vue({
  el:"#app",
  data:{
    parentMsg:"hello 希盟"
  }
})
```
效果:(http://jsbin.com/qiqetayivo/edit?html,js,output)

3、props绑定类型

默认为单向数据绑定,当父组件的属性变化时，将传导给子组件，但是反过来不会；也可以使用 .sync 或 .once 强制双向/单向绑定
```
<!-- 默认为单向绑定 -->
<child :msg="parentMsg"></child>

<!-- 双向绑定 -->
<child :msg.sync="parentMsg"></child>

<!-- 单次绑定 -->
<child :msg.once="parentMsg"></child>
```
四、父子组件通信

1、父链

子组件可以通过this.$parent访问父组件。根实例的后代可以用this.$root访问子组件。父组件有一个数组this.$children,包含它所有的子元素。

2、自定义事件(events)
Vue实例实现了一个自定义事件接口，用于在组件树中通信。

每个Vue实例都是一个事件触发器：

a、使用$on()监听事件;

b、使用$emit()在它上面触发事件;

c、使用$dispatch()派发事件，事件沿着父链冒泡;

d、使用$broadcast()广播事件,事件向下传导给所有的后代。

**使用v-bind绑定自定义事件**

优点：可以很直观的看到父组件代码中的child-msg来自哪里。

```
html
<!-- 子组件模板 -->
<template id="child-template">
  <input v-model="msg">
  <button v-on:click="notify">Dispatch Event</button>
</template>

<!-- 父组件模板 -->
<div id="events-example">
  <p>Messages: {{ messages | json }}</p>
  <child v-on:child-msg="handleIt"></child>
</div>

js
// 注册子组件
// 将当前消息派发出去
Vue.component('child', {
  template: '#child-template',
  data: function () {
    return { msg: 'hello' } //子组件中的数据(组件选项问题,所以data必须作为一个函数使用)
  },
  methods: {
    notify: function () {
      if (this.msg.trim()) {
        this.$dispatch('child-msg', this.msg)
        this.msg = ''
      }
    }
  }
})

// 初始化父组件
// 将收到消息时将事件推入一个数组
var parent = new Vue({
  el: '#events-example',
  data: {
    messages: []
  },
  methods:{//使用$dispatch事件
    handleIt:function(msg){
      this.messages.push(msg)
    }
  }
})
```
效果(http://jsbin.com/hoburariso/edit?html,js,output)

3、子组件索引

v-ref(为子组件指定一个索引ID)可以直接使用子组件

```
html
<div id="app">
  <child v-ref:profile></child>
</div>
js
var vm=new Vue({
  el:"#app"
})
var child=vm.$refs.profile

```
4、动态组件(可以使用tab切换)

a、[<component>、is]多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留<component> 元素，动态地绑定到它的 is 特性;

b、[keep-alive]如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数;

c、[activate]在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 activate 钩子;

```
html

<template id="temp-tab01">
    <div>this is tab01</div>
</template>
<template id="temp-tab02">
    <div>this is tab02</div>
</template>
<template id="temp-tab03">
    <div>this is tab03</div>
</template>

<div id="dr01">
    <!-- 导航栏 -->
    <div class="border cf">
        <ul>
            <li><a href="javascript:;" @click="toggleTabs(tab01Text);">{{tab01Text}}</a></li>
            <li><a href="javascript:;" @click="toggleTabs(tab02Text);">{{tab02Text}}</a></li>
            <li><a href="javascript:;" @click="toggleTabs(tab03Text);">{{tab03Text}}</a></li>
        </ul>
    </div>
    <!-- 点击导航后要切换的内容 -->
    <div class="border" style="height: 100px;">
        <!-- 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数 -->
        <component :is="currentView" keep-alive>
          <tab01></tab01>
          <tab02></tab02>
          <tab03></tab03>
        </component>
    </div>
</div>

js
//扩展组件tab01
var tab01 = Vue.extend({
    template: "#temp-tab01",
});
//扩展组件tab02
var tab02 = Vue.extend({
    template: "#temp-tab02",
});
//扩展组件tab03
var tab03 = Vue.extend({
    template: "#temp-tab03",
});
//新建vue实例
var dr01 = new Vue({
    el: "#dr01",
    data: {
        tab01Text: "tab01", //导航栏文本1
        tab02Text: "tab02", //导航栏文本2
        tab03Text: "tab03", //导航栏文本3
        currentView: 'tab01', //默认选中的导航栏
    },
    //局部注册组件
    components: {
        tab01: tab01,
        tab02: tab02,
        tab03: tab03,
    },
    methods: {
        //绑定tab的切换事件
        toggleTabs: function(tabText) {
            this.currentView = tabText;
        }
    }
});
```
效果(http://jsbin.com/badaziwori/edit?html,js,output)











</xmp>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//httpsfedlovergithubio.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script src="https://fedlover.github.io/js/strapdown.js"></script>
</html>

	