<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<link rel="Shortcut Icon" href="https://avatars2.githubusercontent.com/u/6932025?v=3&s=460" type="image/ico">
<title>vue.js(三)</title>
<style type="text/css">
    #content{margin:0 auto 50px; width: 66%;}
    #disqus_thread{margin:0 auto; width: 66%;}
	.ds-powered-by,.navbar ,.ds-sync{display: none;}
</style>
<xmp theme="united" style="display:none;">

##vue.js(三)

####十、组件

一、含义:是vue.js最强大的功能之一，扩展HTML元素，封装可重用的代码。

二、使用组件

1、全局注册(步骤)

a、先通过Vue.extend()创建组件构造器；

b、通过使用Vue.component()注册，来把构造器用作组件；

c、组件注册后，便可以在父实例模块中通过自定义元素使用(创建根实例)；

```
html

<div id="app">
  <my-component></my-component>
</div>

js

//先创建组件构造器

var MyComponent=Vue.extend({
  template:'<ul><li><h5>11111</h5></li><li><h5>22222</h5></li><li><h5>33333</h5></li><li><h5>44444</h5></li><li><h5>55555</h5></li></ul>'
})

//注册(把构造器用作组件)(用组件的模块Mycomponent替换了自定义元素my-conpoment)
Vue.component('my-conpoment',Mycomponent)

//创建根实例

var vm=new Vue({
  el:"#app"
})
```
2、局部注册(components)

不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 components 注册：

```
html:
<div id="app">
  <parent></parent>
</div>

js:

//创建子组件构造器
var Child=Vue.extend({
  template:"<div>child</div>"
})
//创建父组件构造器，并把子组件放到父模块中
var Parent=Vue.extend({
  template:"<div><h4>父组件：<child></child></h4></div>",
  注册子组件：
  components:{
    "child":Child
  }

})
//创建根实例

var vm=new Vue({
  el:"#app",
  注册父组件
  components:{
    "parent":Parent
  }
})

```
3、注册语法糖(不需要创建组件构造器)：

为了让事件更简单，可以直接传入选项对象而不是构造器给 Vue.component() 和 component 选项。Vue.js 在背后自动调用 Vue.extend()：

```
全局：
Vue.component("my-component",{
  template:'<ul><li><h5>11111</h5></li><li><h5>22222</h5></li><li><h5>33333</h5></li><li><h5>44444</h5></li><li><h5>55555</h5></li></ul>'
})

局部：

var Parent=Vue.extend({
  template:"<div>parent: <child></child></div>",
  components:{
    "child":{
        template:'<div>child</div>'
    }
  }
})
var vm=new Vue({
  el:"#app",
  components:{
    "parent":Parent
  }
})

```
4、组件选项问题
在vue.js构造器(Vue.extend)中data和el必须作为一个函数使用。

`var MyComponent = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
`

三、Props

1、使用props传递数据

不能在子组件的模板内直接使用父组件的数据，要通过Props把数据传给子组件。

```
html
<div id="app">
  <child msg="hello"></child>
</div>

js
var Child=Vue.component("child",{
显式地用 props 选项 声明 props：
  props:['msg'],
  template:'<span>{{msg}}</span>'-->通过props拿到父元素的数据“hello”
})
var vm=new Vue({
  el:"#app"
})
```
**2、动态props**

用v-bind绑定动态的props到父组件的数据。每当父组件数据变化时，子组件也会相应的改变。

```
html

<div id="app">
  <input v-model="parentMsg">
  <br>
  <child v-bind:message="parentMsg"></child>
</div>

js

var Child=Vue.component("child",{
  props:['message'],
  template:'<div><span>{{message}}</span></div>'
})
var vm=new Vue({
  el:"#app",
  data:{
    parentMsg:"hello 希盟"
  }
})
```
效果:(http://jsbin.com/qiqetayivo/edit?html,js,output)

3、props绑定类型

默认为单向数据绑定,当父组件的属性变化时，将传导给子组件，但是反过来不会；也可以使用 .sync 或 .once 强制双向/单向绑定
```
<!-- 默认为单向绑定 -->
<child :msg="parentMsg"></child>

<!-- 双向绑定 -->
<child :msg.sync="parentMsg"></child>

<!-- 单次绑定 -->
<child :msg.once="parentMsg"></child>
```
四、父子组件通信

1、父链

子组件可以通过this.$parent访问父组件。根实例的后代可以用this.$root访问子组件。父组件有一个数组this.$children,包含它所有的子元素。

2、自定义事件(events)
Vue实例实现了一个自定义事件接口，用于在组件树中通信。

每个Vue实例都是一个事件触发器：

a、使用$on()监听事件;

b、使用$emit()在它上面触发事件;

c、使用$dispatch()派发事件，事件沿着父链冒泡;

d、使用$broadcast()广播事件,事件向下传导给所有的后代。

**使用v-bind绑定自定义事件**

优点：可以很直观的看到父组件代码中的child-msg来自哪里。

```
html
<!-- 子组件模板 -->
<template id="child-template">
  <input v-model="msg">
  <button v-on:click="notify">Dispatch Event</button>   
</template>

<!-- 父组件模板 -->
<div id="events-example">
  <p>Messages: {{ messages | json }}</p>
  <child v-on:child-msg="handleIt"></child>   //通过v-on: 实现父子组件之间的通信
</div>

js
// 注册子组件
// 将当前消息派发出去
Vue.component('child', {
  template: '#child-template',
  data: function () {
    return { msg: 'hello' } //子组件中的数据(组件选项问题,所以data必须作为一个函数使用)
  },
  methods: {
    notify: function () {
      if (this.msg.trim()) {
        this.$dispatch('child-msg', this.msg)  //派发事件，事件沿着父链冒泡
        this.msg = ''
      }
    }
  }
})

// 初始化父组件
// 将收到消息时将事件推入一个数组
var parent = new Vue({
  el: '#events-example',
  data: {
    messages: []
  },
  methods:{//使用$dispatch事件
    handleIt:function(msg){
      this.messages.push(msg)
    }
  }
})
```
效果(http://jsbin.com/hoburariso/edit?html,js,output)

3、子组件索引

v-ref(为子组件指定一个索引ID)可以直接使用子组件

```
html
<div id="app">
  <child v-ref:profile></child>
</div>
js
var vm=new Vue({
  el:"#app"
})
var child=vm.$refs.profile

```
4、动态组件(可以使用tab切换)

a、[<component>、is]多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留<component> 元素，动态地绑定到它的 is 特性;

b、[keep-alive]如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数;

c、[activate]在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 activate 钩子;

```
html

<template id="temp-tab01">
    <div>this is tab01</div>
</template>
<template id="temp-tab02">
    <div>this is tab02</div>
</template>
<template id="temp-tab03">
    <div>this is tab03</div>
</template>

<div id="dr01">
    <!-- 导航栏 -->
    <div class="border cf">
        <ul>
            <li><a href="javascript:;" @click="toggleTabs(tab01Text);">{{tab01Text}}</a></li>
            <li><a href="javascript:;" @click="toggleTabs(tab02Text);">{{tab02Text}}</a></li>
            <li><a href="javascript:;" @click="toggleTabs(tab03Text);">{{tab03Text}}</a></li>
        </ul>
    </div>
    <!-- 点击导航后要切换的内容 -->
    <div class="border" style="height: 100px;">
        <!-- 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数 -->
        <component :is="currentView" keep-alive>
          <tab01></tab01>
          <tab02></tab02>
          <tab03></tab03>
        </component>
    </div>
</div>

js
//扩展组件tab01
var tab01 = Vue.extend({
    template: "#temp-tab01",
});
//扩展组件tab02
var tab02 = Vue.extend({
    template: "#temp-tab02",
});
//扩展组件tab03
var tab03 = Vue.extend({
    template: "#temp-tab03",
});
//新建vue实例
var dr01 = new Vue({
    el: "#dr01",
    data: {
        tab01Text: "tab01", //导航栏文本1
        tab02Text: "tab02", //导航栏文本2
        tab03Text: "tab03", //导航栏文本3
        currentView: 'tab01', //默认选中的导航栏
    },
    //局部注册组件
    components: {
        tab01: tab01,
        tab02: tab02,
        tab03: tab03,
    },
    methods: {
        //绑定tab的切换事件
        toggleTabs: function(tabText) {
            this.currentView = tabText;
        }
    }
});
```
效果(http://jsbin.com/badaziwori/edit?html,js,output)

####十一、深入响应式原理

1、初始化数据

尽管Vue.js可以动态的添加响应属性，但是还是推荐在data对象上声明所有的响应属性。

```
不要求这样做

var vm=new Vue({
  template:"<div>{{message}}</div>"
})
vm.$set("message","hello")

**推荐这样做**
var vm=new Vue({
  data:{
    message:""
  },
  template:"<div>{{message}}</div>"
})
vm.message="hello"
```
2、异步更新队列

如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。

vm.$nextTick()可以在数据变化后，Dom立即更新。

```
Vue.component("example",{
  template:"<div>{{message}}</div>",
  data:function(){
    return {
      message:"hello"
    }
  },
  methods:{
    updataMessage:function(){
      this.message="hello 希盟"
      console.log(this.$el.textContent)-->没有更新
      this.$nextTick(function(){
        console.log(this.$el.textContent)-->更新
      })
    }
  }
})
```
####十二、自定义指令

1、除了内置指令，Vue.js 也允许注册自定义指令Vue.directive,将数据的变化直接映射到Dom上。

2、钩子函数

定义对象可以提供几个**钩子函数**（都是可选的）：

bind：只调用一次，在指令第一次绑定到元素上时调用。

update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。

unbind：只调用一次，在指令从元素上解绑时调用。
```
//注册自定义指令
Vue.directive("example",{
  bind:function(){

  },
  update:function(newValue,oldValue){

  },
  unbind:function(){}
})
//注册之后在vue.js模板中这样使用，一定要加前缀v-
<div v-example="someValue"></div>
```
3、指令实例属性

所有的钩子函数将被复制到实际的指令对象中，钩子内 this 指向这个指令对象。这个对象暴露了一些有用的属性：

el: 指令绑定的Dom元素。
vm: 拥有该指令的上下文 ViewModel对象。this.vm.$el=this.el
expression: 指令的表达式，不包括参数和过滤器。
arg: 指令的参数。
name: 指令的名字，不包含前缀。
modifiers: 一个对象，包含指令的修饰符。
descriptor: 一个对象，包含指令的解析结果。
```
html

<div id="example" v-demo="args: message" v-on:click="onClick"></div>
js
Vue.directive('demo', {
    acceptStatement: true, //让自定义指令接受内联语句
    bind: function(){
        this.el.style.cssText = 'color: red; background: #666;';
    },
    update: function(newVal, oldVal){
        this.el = 'name = ' + this.name + '<br/>' + 
            'arg = ' + this.arg + '<br/>' + 
            'expression= ' + this.expression+ '<br/>';
        console.log(this.vm.$data);   //vm.data的信息
        console.log(this.el)  //<div id="example" style="color: red; background: rgb(102, 102, 102);"></div>
        console.log(this.vm.$el)  //div#example
        console.log(this.el === this.vm.$el); //true
    }
});
var vm = new Vue({
    el: '#example',
    data: {
        message: 'hello world!'
    },
    methods: {
        onClick: function(){
            // custom directive update will be called.
            this.$data.message = 'hahaha!';
        }
    }
});

```
4、对象字面量
```
html
<div v-demo="{'background':'pink','color':'white'}"></div>
js
Vue.directive("demo",function(value){
  console.log(value.background)
  console.log(value.color)
})
```
5、自定义元素指令
```
<my-directive></my-directive>
Vue.elementDirective("my-directive",{
  bind:function(){

  }
})
```
####十三、自定义过滤器

可以通过Vue.filter()注册一个自定义过滤器。它接受两个参数:过滤器ID和过滤器函数
```
html
<span v-text="message | reverse"></span>
js
Vue.filter("reverse",function(value){
  return value.split("").reverse().join("")
})
```

a、动态参数
```
html
<div id="app" v-model="message">
  <span>{{msg | concat message}}</span>
</div>
js
Vue.filter("concat",function(value,input){
  return value+input
})
```
####十四、混合

a、选项合并mixins
```
var mix={
  methods:{
    bar:function(){
      console.log("bar")
    },
    confix:function(){
      console.log("confix")
    }
  }
}
var vm=new Vue({
  mixins:[mix],  //必须使用mixins(混合)
  methods:{
    two:function(){
      console.log("two")
    },
    confix:function(){
      console.log("confix")
    }
  }
})
vm.two()
vm.confix()
vm.bar()
```
####十五、插件

1、开发插件

插件通常会为Vue.js提供全局功能。

1、添加全局方法或属性，如 vue-element。
2、添加全局资源：指令/过滤器/过渡等，如 vue-touch。
3、添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。
4、一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router。

Vue.js 的插件应当有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。
```
MyPlugin.install=function(Vue,options){
  1、添加全局方法或属性
  Vue.myGlobalMethod=
  2、添加全局资源
  Vue.directive('my-directive',{})
  3、添加实例方法
  Vue.prototype.$myMethod=
}
```

2、使用插件

通过Vue.use()使用插件

`
Vue.use(MyPlugin)
`
也可以传入一个选项对象

`
Vue.use(MyPlugin,{someOption:true})
`







</xmp>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//httpsfedlovergithubio.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script src="https://fedlover.github.io/js/strapdown.js"></script>
</html>

	