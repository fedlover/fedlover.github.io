<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<title>立即调用函数表达式</title>
<style type="text/css">
    #content {
        margin: 0 auto 50px;
        width: 66%;
        min-height: 600px;
    }
    
    #ds-reset {
        margin: 0 auto;
        width: 66%;
    }
    
    .ds-powered-by,
    .navbar,
    .ds-sync,
    .ds-comments-info,
    .ds-meta {
        display: none;
    }
</style>
<xmp theme="united" style="display:none;">
##自执行

###什么是自执行

在JavaScript里，任何function在执行的时候都会创建一个执行上下文，因为为function声明的变量和function有可能只在该function内部，这个上下文，在调用function的时候，提供了一种简单的方式来创建自由变量或私有子function。

```
//由于该function里返回了另一个function，其中这个function可以访问自由变量i

//所以说，这个内部的function实际上有权限可以调用内部的对象.

function makeCounter(){
    //只能在markeCounter内部访问i
    
    var i=0;
    
    return function(){
        console.log(++i);
    }
}

var counter=makeCounter();

counter();//1

alert(i) //引用错误,i没有defind(因为i是存在makeCounter内部)。

```

###问题的核心

当你声明类似function foo(){}或var foo=function(){}函数的

时候,通过在后面加个括弧就可以实现自执行，例如：foo()

```
// 因为想下面第一个声明的function可以在后面加一个括弧()就可以自

己执行了，比如foo()，

// 因为foo仅仅是function() { /* code */ }这个表达式的一个引用

var foo = function(){ /* code */ }

// ...是不是意味着后面加个括弧都可以自动执行？

function(){ /* code */ }()

```
上述代码,如果执行，第2个代码会出错,因为在解析器解析全局的function 或者function内部function关

键字的时候，默认是认为function声明，而不是function表达式，如果你不显示告诉编译器，它默认会声明

成一个缺少名字的function，并且抛出一个语法错误信息，因为function声明需要一个名字。


###自执行函数表达式

要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为JavaScript里括弧()

里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成

function表达式，而不是function声明。

```
// 下面2个括弧()都会立即执行

(function () { /* code */ } ()); // 推荐使用这个

(function () { /* code */ })(); // 但是这个也是可以用的
```

###用闭包保存状态

和普通function执行的时候传参数一样，自执行的函数表达式也可以这么传参，因为闭包直接可以引用传入的

这些参数，利用这些被lock住的传入参数，自执行函数表达式可以有效地保存状态。

```
var elems = document.getElementsByTagName('a');

for(var i=0; i<lelems.length; i++){
    (function(index){
        elems[i].addEventListener('click',function(e){
            alert(index);
        })
    })(i)
}

```

</xmp>
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="1" data-title="前端AD页面制作要点" data-url="http://pearyman.github.io/blog/2015/blog01.html"></div>
<!-- 多说评论框 end -->
<script type="text/javascript">
    var duoshuoQuery = {
        short_name: "pearyman"
    };
    (function () {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<script src="https://fedlover.github.io/js/strapdown.js"></script>

</html>