<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<title>变量的两种不同数据类型的值</title>
<style type="text/css">
    #content{margin:0 auto 50px; width: 66%; min-height: 600px;}
    #ds-reset{margin:0 auto; width: 66%;}
	.ds-powered-by,.navbar,.ds-sync,.ds-comments-info,.ds-meta{display: none;}
</style>
<xmp theme="united" style="display:none;">
##变量

###基本类型和引用类型的值

基本类型:五种基本数据类型;

引用类型:保存在内存中的对象;

在将一个值赋值给变量时,解析器必须确定这个值是基本类型还是引用类型的值。

基本数据类型是按值访问的,因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。与其他语言不同，javascript不允许直接访问内存中的位置,也就是说不能直接操作对象的内存空间。*在操作对象时,实际上是操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。*

###动态的属性

定义基本类型值和引用类型值的方式是类似的:创建一个变量并为其赋值。但是当这个值保存到变量后,对其操作是大相径庭的。对于引用类型的值,我们可以为其添加属性和方法,也可以改变和删除属性和方法。
(一、)引用类型
```
var person=new Object()//引用类型的值

person.name="join";

alert(person.name);//"join"

注: 创建了一个对象并将其保存在了一个变量person中。然后为这个对象添加了一个name的属性。如果对象不被销毁或者这个属性不被删除，这个属性将一直都在。
```
(二、)基本类型
```
var name="join";

name.age=27;

alert(name.age);//undefined;

注:这就是基本类型和引用类型的区别
```

###复制变量值

除了保存的方式不同之外,从一个变量向另一个变量复制基本类型值和引用类型值时,也存在不同。

(一、)基本类型

如果从一个变量向另一个变量复制基本类型的值时，会在变量对象上创建一个新值，然后再把该值复制到为新变量分配的位置上。

```
var num1=1;

var num2=num1;//1

注：*虽然num2的值也为1,但是num2中1和num1中1是完全独立的,该值只是num1中1的副本。并且这两个变量可以参与任何操作而不会相互影响。*
```
(二、)引用类型

当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针,这个指针指向存储在堆中的一个对象。复制结束后，两个变量实际上将引用同一个对象。*因此,改变一个变量就会影响到另一个变量。*

```
var obj1=new Object();
var obj2=obj1;
obj1.name="join";
alert(obj2.nam)//"join";

注:obj1和obj2都指向同一个对象。
```
###传递参数

ESMAScript中的所有函数的参数都是按值传递的。因此访问变量有按值和引用两种方式，而参数只能按值传递。
(一、)基本类型

在向参数传递基本类型的值时,*被传递的值会被复制给一个局部变量*。在向参数传递引用类型的值时,*会把这个值在内存中的地址复制给一个变量。*

```
function addTen(num){
    num+=10;
    return num;
}
var count=20;
var result=addTen(count);
console.log(result)//30;
console.log(count)//20没有变化;

这里的函数addTen()有一个参数num,而参数实际上是函数的局部变量。在调用这个函数时,变量count作为参数被传递给函数。在函数内部，参数num的值被加上了10，但这一改变并不会影响到外面变量count的值。参数num和变量cont互不相识,它们仅仅是具有相同的值。*如果按引用类型传递的话,那么count的值也会变成30,所以传递参数还是按值比较简单。*

```
(二、)引用类型

```
function setName(obj){
    obj.name="join";
}
var person=new Object();
setName(person);
console.log(person.name)//"join"

person和obj都指向同一个对象Object,一个改变会影响到另一个的改变。
```
**(三)值和引用同时存在**

为了证明对象是按值传递的,看下面的例子

```
function setName(obj){
    obj.name="join";
    obj=new Object();
    obj.name="ruby";
}
var person=new Object();
setName(person);
console.log(person.name);//*join*
```

</xmp>
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="1" data-title="js检测手机是否安装某一app" data-url="http://pearyman.github.io/blog/2015/blog02.html"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"pearyman"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<script src="https://fedlover.github.io/js/strapdown.js"></script>
</html>
