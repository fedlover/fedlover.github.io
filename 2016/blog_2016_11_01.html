<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="generator" content="Pearyman'S BLOG">
<meta name="author" content="Pearyman">
<meta name="description" content="html5,css3,app" />
<meta name="keywords" content="Pearyman,BLOG" />
<title>深入理解DOM中的事件对象</title>
<style type="text/css">
    #content{margin:0 auto 50px; width: 66%; min-height: 600px;}
    #ds-reset{margin:0 auto; width: 66%;}
	.ds-powered-by,.navbar,.ds-sync,.ds-comments-info,.ds-meta{display: none;}
</style>
<xmp theme="united" style="display:none;">
###深入理解DOM中事件对象

####1、在触发DOM上的某个事件时，会在事件处理函数中产生一个事件对象event，这个对象中包含了所有与事件有关的信息，包括导致事件的元素、事件类型等。

*event.type*属性表示事件类型;

*event的属性currentTarget*表示当前正在处理事件的那个元素;

*event的属性target*表示事件的目标;

**在事件处理程序内部,`this始终指向的是currentTarget的值`;target只包含事件的实际目标。**

currentTarget和target的区别:

target指向被单击的对象，currentTarget指向当前事件活动的对象(一般是指向父级)。

比如说现在有A和B， A.addChild(B) A监听鼠标点击事件 那么当点击B时，target是B，currentTarget是A 

也就是说，currentTarget始终是监听事件者，而target是事件的真正发出者。

```
  <div class="out">
    out
    <p class="inner">
      inner
    </p>
  </div>
  console.log(event.currentTarget)-->div
```
注: 当点击在out上时，currentTarget和target都是div;而当点击在inner上时,currentTarget是div而target是p。

一个目标多少事件:

```
<div id="out">out</div>
<script>
  var out=document.getElementById("out");
  var handel=function(event){
    switch(event.type){
      case "click":
      console.log("click");
      break;
      case "mouseover":
      event.target.style.background="pink";
      break;
      case "mouseout":
      event.target.style.background="blue";
      break;
    }
    out.onclick=handel;
    out.onmouseover=handel;
    out.onmouseout=handel;
  }
</script>
```

event属性的preventDefault()方法,阻止事件的默认行为;

event属性的stopPropagation()方法,阻止事件的冒泡行为;

```
var btn=document.getElementById("btn");
btn.onclick=function(event){
  console.log("btn");
  event.stopPropagation();
}
document.body.onclick=function(event){
  console.log("body");
}
```
注:不加event.stopPropagation()方式时,浏览器会输出"btn"和"body",当前只输出"btn"。

####2、IE中或取event事件目标的属性是srcElement

event对象作为window对象的存在:

IE中event获取事件目标的属性是srcElement

####3、跨浏览器的事件对象

```
eventList={
  getEvent:function(event){
    return event? event : window.event;
  },
  getTarget:function(event){//在非IE情况下获取事件目标和IE情况下获取事件目标;
    return event.target || event.srcElement;
  },
  getPrevent:function(event){
    if(event.preventDefault()){
        event.preventDefault();
    }else{
      event.returnValue=false;//IE阻止事件的默认行为;
    }
  },
  getStop:function(event){
    if(event.stopPropagation()){
        event.stopPropagation();
    }else{
      event.cancelBubble=true;
    }
  }
}

btn.onclick=function(event){
  var 
  event=eventList.getEvent(event),
  target=eventList.getTarget(event.target);

}
```
####4、事件处理程序过多,会占用内存,导致性能变差,解决方法是利用事件委托来管理一类事件。例如:click事件会一直冒泡到document层,我们可以为整个页面制定一个onclick事件处理程序,而不必为每个单击的元素添加事件处理程序。

```
<ul id="list">
  <li id="first">111</li>
  <li id="second">111</li>
  <li id="three">111</li>
</ul>

方法一:

var item1=document.getElementById("first"),
    item2=document.getElementById("second"),
    item3=document.getElementById("three");

    item1.onclick=function(){
      console.log("item1");
    }
    item2.onclick=function(){
      console.log("item2");
    }
    item3.onclick=function(){
      console.log("item3");
    }

注: 如果在一个复杂的web应用程序中都使用这种方式，那就会有无数的代码添加事件处理程序，然而可以

事件委托技术解决，*就是在DOM树的尽量最高的层次添加一个事件处理程序：*

方法二:事件委托

var list=document.getElementById("list");

list.onclick=function(event){
  switch(target.id){
    case "first":
    console.log("first");
    break;
    case "second":
    console.log("second");
    break;
    case "three":
    console.log("three");
    break;

  }
}

```
注: 把事件委托给目标的父元素或者祖先元素，给ul添加一个onclick事件处理程序，由于所有目标元素都是这个元素的子节点，而且他们也会获得一个onclick事件

，由于事件会冒泡，所以点击事件最终会被ul元素的处理事件程序处理。采用事件委托技术只添加了一个事件处理程序，占用的内存更少。

及时解除事件绑定可以减少占用内存和提高性能。

两个条件：

1、用innerHTML替换元素原来的内容;

2、移除DOM0级、DOM2级和IE的事件处理程序;

```
<div id="box">
  <div id="btn">btn</div>
</div>

var btn=document.getElementById("btn");

btn.onclick=function(){
  btn.onclick=null;//移除事件处理程序;

  document.getElementById("btn").innerHTML="changing"
}
```



</xmp>
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="1" data-title="js检测手机是否安装某一app" data-url="http://pearyman.github.io/blog/2015/blog02.html"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"pearyman"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<script src="https://fedlover.github.io/js/strapdown.js"></script>
</html>
